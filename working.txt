AssertionError: 
[b'//init varibles with default values lets there are issues reading them from config\r\n', b'let global_brightness = 0.5\r\n', b'let global_whiteBalanceFactors = {\r\n', b'    "red": 1.0,\r\n', b'    "green": 0.8,\r\n', b'    "blue": 0.6\r\n', b'}\r\n', b'let global_gamma = 2.2\r\n', b'const brightnessScaler = 100;\r\n', b'\r\n', b'\r\n', b'function setColorGlobals(shiftLightConfig) {\r\n', b'    whiteBalance_factors = shiftLightConfig.whiteBalance_factors\r\n', b'    gamma = shiftLightConfig.gamma\r\n', b'    brightness = shiftLightConfig.brightness\r\n', b'}\r\n', b'\r\n', b'// Helper function to convert RGB color to HEX\r\n', b'function rgbToHex(rgb) {\r\n', b'    const result = rgb.match(/\\d+/g).map(Number);\r\n', b'    return `#${((1 << 24) + (result[0] << 16) + (result[1] << 8) + result[2]).toString(16).slice(1).toUpperCase()}`;\r\n', b'}\r\n', b'\r\n', b'function hexToRgb(hex) {\r\n', b'    hex = hex.replace(/^#/, "");\r\n', b'    let r = parseInt(hex.substring(0, 2), 16);\r\n', b'    let g = parseInt(hex.substring(2, 4), 16);\r\n', b'    let b = parseInt(hex.substring(4, 6), 16);\r\n', b'    return { "red": r, "green": g, "blue": b };\r\n', b'}\r\n', b'\r\n', b'function rgbToHsv(r, g, b) {\r\n', b'    r /= 255, g /= 255, b /= 255;\r\n', b'    let max = Math.max(r, g, b), min = Math.min(r, g, b);\r\n', b'    let h, s, v = max;\r\n', b'    let d = max - min;\r\n', b'    s = max === 0 ? 0 : d / max;\r\n', b'\r\n', b'    if (max === min) {\r\n', b'        h = 0;\r\n', b'    } else if (max === r) {\r\n', b'        h = (60 * ((g - b) / d) + 360) % 360;\r\n', b'    } else if (max === g) {\r\n', b'        h = (60 * ((b - r) / d) + 120) % 360;\r\n', b'    } else {\r\n', b'        h = (60 * ((r - g) / d) + 240) % 360;\r\n', b'    }\r\n', b'\r\n', b'    return { h, s, v };\r\n', b'}\r\n', b'\r\n', b'function hsvToRgb(h, s, v) {\r\n', b'    h = h % 360;\r\n', b'    let c = v * s;\r\n', b'    let x = c * (1 - Math.abs((h / 60) % 2 - 1));\r\n', b'    let m = v - c;\r\n', b'    let r, g, b;\r\n', b'\r\n', b'    if (0 <= h && h < 60) {\r\n', b'        r = c, g = x, b = 0;\r\n', b'    } else if (60 <= h && h < 120) {\r\n', b'        r = x, g = c, b = 0;\r\n', b'    } else if (120 <= h && h < 180) {\r\n', b'        r = 0, g = c, b = x;\r\n', b'    } else if (180 <= h && h < 240) {\r\n', b'        r = 0, g = x, b = c;\r\n', b'    } else if (240 <= h && h < 300) {\r\n', b'        r = x, g = 0, b = c;\r\n', b'    } else {\r\n', b'        r = c, g = 0, b = x;\r\n', b'    }\r\n', b'\r\n', b'    return {\r\n', b'        red: Math.round((r + m) * 255),\r\n', b'        green: Math.round((g + m) * 255),\r\n', b'        blue: Math.round((b + m) * 255)\r\n', b'    };\r\n', b'}\r\n', b'\r\n', b'function rgbStringToObject(rgbString) {\r\n', b'    const match = rgbString.match(/^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/);\r\n', b'    if (!match) {\r\n', b'        throw new Error("Invalid RGB string format: " + rgbString);\r\n', b'    }\r\n', b'    return {\r\n', b'        red: parseInt(match[1]),\r\n', b'        green: parseInt(match[2]),\r\n', b'        blue: parseInt(match[3])\r\n', b'    };\r\n', b'}\r\n', b'\r\n', b'function applyColorAdjustments(color, brightness = global_brightness, gamma = global_gamma, colorFactors = global_whiteBalanceFactors) {\r\n', b'    // Step 1: Apply brightness adjustment\r\n', b'    let { h, s, v } = rgbToHsv(color.red, color.green, color.blue);\r\n', b'    v *= brightness;\r\n', b'    let adjustedColor = hsvToRgb(h, s, v);\r\n', b'\r\n', b'    // Step 2: Apply gamma correction\r\n', b'    adjustedColor = {\r\n', b'        red: Math.round(255 * Math.pow(adjustedColor.red / 255, gamma)),\r\n', b'        green: Math.round(255 * Math.pow(adjustedColor.green / 255, gamma)),\r\n', b'        blue: Math.round(255 * Math.pow(adjustedColor.blue / 255, gamma))\r\n', b'    };\r\n', b'\r\n', b'    // Step 3: Apply white balance adjustment\r\n', b'    return {\r\n', b'        red: Math.round(adjustedColor.red * colorFactors.red),\r\n', b'        green: Math.round(adjustedColor.green * colorFactors.green),\r\n', b'        blue: Math.round(adjustedColor.blue * colorFactors.blue)\r\n', b'    };\r\n', b'}\r\n', b'\r\n', b'function reverseColorAdjustments(color, brightness = global_brightness, gamma = global_gamma, colorFactors = global_whiteBalanceFactors) {\r\n', b'    // Step 1: Reverse white balance adjustment\r\n', b'    let corrected = {\r\n', b'        red: color.red / colorFactors.red,\r\n', b'        green: color.green / colorFactors.green,\r\n', b'        blue: color.blue / colorFactors.blue\r\n', b'    };\r\n', b'\r\n', b'    // Step 2: Reverse gamma correction\r\n', b'    corrected = {\r\n', b'        red: Math.pow(corrected.red / 255, 1 / gamma) * 255,\r\n', b'        green: Math.pow(corrected.green / 255, 1 / gamma) * 255,\r\n', b'        blue: Math.pow(corrected.blue / 255, 1 / gamma) * 255\r\n', b'    };\r\n', b'\r\n', b'    // Step 3: Reverse brightness adjustment\r\n', b'    let { h, s, v } = rgbToHsv(corrected.red, corrected.green, corrected.blue);\r\n', b'    v /= brightness;\r\n', b'    return hsvToRgb(h, s, v);\r\n', b'}\r\n'] vs (expected) 
[b'//init varibles with default values lets there are issues reading them from config\r\nlet global_brightness = 0.5\r\nlet global_whiteBalanceFactors = {\r\n    "red": 1.0,\r\n    "green": 0.8,\r\n    "blue": 0.6\r\n}\r\nlet global_gamma = 2.2\r\nconst brightnessScaler = 100;\r\n\r\n\r\nfunction setColorGlobals(shiftLightConfig) {\r\n    whiteBalance_factors = shiftLightConfig.whiteBalance_factors\r\n    gamma = shiftLightConfig.gamma\r\n    brightness = shiftLightConfig.brightness\r\n}\r\n\r\n// Helper function to convert RGB color to HEX\r\nf', b'unction rgbToHex(rgb) {\r\n    const result = rgb.match(/\\d+/g).map(Number);\r\n    return `#${((1 << 24) + (result[0] << 16) + (result[1] << 8) + result[2]).toString(16).slice(1).toUpperCase()}`;\r\n}\r\n\r\nfunction hexToRgb(hex) {\r\n    hex = hex.replace(/^#/, "");\r\n    let r = parseInt(hex.substring(0, 2), 16);\r\n    let g = parseInt(hex.substring(2, 4), 16);\r\n    let b = parseInt(hex.substring(4, 6), 16);\r\n    return { "red": r, "green": g, "blue": b };\r\n}\r\n\r\nfunction rgbToHsv(r, g, b) {\r\n    r /= 255, g /= 255, b', b' /= 255;\r\n    let max = Math.max(r, g, b), min = Math.min(r, g, b);\r\n    let h, s, v = max;\r\n    let d = max - min;\r\n    s = max === 0 ? 0 : d / max;\r\n\r\n    if (max === min) {\r\n        h = 0;\r\n    } else if (max === r) {\r\n        h = (60 * ((g - b) / d) + 360) % 360;\r\n    } else if (max === g) {\r\n        h = (60 * ((b - r) / d) + 120) % 360;\r\n    } else {\r\n        h = (60 * ((r - g) / d) + 240) % 360;\r\n    }\r\n\r\n    return { h, s, v };\r\n}\r\n\r\nfunction hsvToRgb(h, s, v) {\r\n    h = h % 360;\r\n    let c = v * s;\r', b'\n    let x = c * (1 - Math.abs((h / 60) % 2 - 1));\r\n    let m = v - c;\r\n    let r, g, b;\r\n\r\n    if (0 <= h && h < 60) {\r\n        r = c, g = x, b = 0;\r\n    } else if (60 <= h && h < 120) {\r\n        r = x, g = c, b = 0;\r\n    } else if (120 <= h && h < 180) {\r\n        r = 0, g = c, b = x;\r\n    } else if (180 <= h && h < 240) {\r\n        r = 0, g = x, b = c;\r\n    } else if (240 <= h && h < 300) {\r\n        r = x, g = 0, b = c;\r\n    } else {\r\n        r = c, g = 0, b = x;\r\n    }\r\n\r\n    return {\r\n        red: Math.r', b'ound((r + m) * 255),\r\n        green: Math.round((g + m) * 255),\r\n        blue: Math.round((b + m) * 255)\r\n    };\r\n}\r\n\r\nfunction rgbStringToObject(rgbString) {\r\n    const match = rgbString.match(/^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/);\r\n    if (!match) {\r\n        throw new Error("Invalid RGB string format: " + rgbString);\r\n    }\r\n    return {\r\n        red: parseInt(match[1]),\r\n        green: parseInt(match[2]),\r\n        blue: parseInt(match[3])\r\n    };\r\n}\r\n\r\nfunction applyColorAdjustments(color, brightness = glo', b'bal_brightness, gamma = global_gamma, colorFactors = global_whiteBalanceFactors) {\r\n    // Step 1: Apply brightness adjustment\r\n    let { h, s, v } = rgbToHsv(color.red, color.green, color.blue);\r\n    v *= brightness;\r\n    let adjustedColor = hsvToRgb(h, s, v);\r\n\r\n    // Step 2: Apply gamma correction\r\n    adjustedColor = {\r\n        red: Math.round(255 * Math.pow(adjustedColor.red / 255, gamma)),\r\n        green: Math.round(255 * Math.pow(adjustedColor.green / 255, gamma)),\r\n        blue: Math.round(255 * Ma', b'th.pow(adjustedColor.blue / 255, gamma))\r\n    };\r\n\r\n    // Step 3: Apply white balance adjustment\r\n    return {\r\n        red: Math.round(adjustedColor.red * colorFactors.red),\r\n        green: Math.round(adjustedColor.green * colorFactors.green),\r\n        blue: Math.round(adjustedColor.blue * colorFactors.blue)\r\n    };\r\n}\r\n\r\nfunction reverseColorAdjustments(color, brightness = global_brightness, gamma = global_gamma, colorFactors = global_whiteBalanceFactors) {\r\n    // Step 1: Reverse white balance adjustmen', b't\r\n    let corrected = {\r\n        red: color.red / colorFactors.red,\r\n        green: color.green / colorFactors.green,\r\n        blue: color.blue / colorFactors.blue\r\n    };\r\n\r\n    // Step 2: Reverse gamma correction\r\n    corrected = {\r\n        red: Math.pow(corrected.red / 255, 1 / gamma) * 255,\r\n        green: Math.pow(corrected.green / 255, 1 / gamma) * 255,\r\n        blue: Math.pow(corrected.blue / 255, 1 / gamma) * 255\r\n    };\r\n\r\n    // Step 3: Reverse brightness adjustment\r\n    let { h, s, v } = rgbToHs', b'v(corrected.red, corrected.green, corrected.blue);\r\n    v /= brightness;\r\n    return hsvToRgb(h, s, v);\r\n}\r\n']